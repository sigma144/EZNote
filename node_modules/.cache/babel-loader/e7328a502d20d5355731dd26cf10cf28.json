{"ast":null,"code":"'use strict';\n\nconsole.log('WebAudioFont Player v2.80');\n\nvar WebAudioFontLoader = require('./loader');\n\nvar WebAudioFontChannel = require('./channel');\n\nvar WebAudioFontReverberator = require('./reverberator');\n\nfunction WebAudioFontPlayer() {\n  this.envelopes = [];\n  this.loader = new WebAudioFontLoader(this);\n  this.onCacheFinish = null;\n  this.onCacheProgress = null;\n  this.afterTime = 0.05;\n  this.nearZero = 0.000001;\n\n  this.createChannel = function (audioContext) {\n    return new WebAudioFontChannel(audioContext);\n  };\n\n  this.createReverberator = function (audioContext) {\n    return new WebAudioFontReverberator(audioContext);\n  };\n\n  this.limitVolume = function (volume) {\n    if (volume) {\n      volume = 1.0 * volume;\n    } else {\n      volume = 0.5;\n    }\n\n    return volume;\n  };\n\n  this.queueChord = function (audioContext, target, preset, when, pitches, duration, volume, slides) {\n    volume = this.limitVolume(volume);\n\n    for (var i = 0; i < pitches.length; i++) {\n      this.queueWaveTable(audioContext, target, preset, when, pitches[i], duration, volume - Math.random() * 0.01, slides);\n    }\n  };\n\n  this.queueStrumUp = function (audioContext, target, preset, when, pitches, duration, volume, slides) {\n    pitches.sort(function (a, b) {\n      return b - a;\n    });\n    this.queueStrum(audioContext, target, preset, when, pitches, duration, volume, slides);\n  };\n\n  this.queueStrumDown = function (audioContext, target, preset, when, pitches, duration, volume, slides) {\n    pitches.sort(function (a, b) {\n      return a - b;\n    });\n    this.queueStrum(audioContext, target, preset, when, pitches, duration, volume, slides);\n  };\n\n  this.queueStrum = function (audioContext, target, preset, when, pitches, duration, volume, slides) {\n    volume = this.limitVolume(volume);\n\n    if (when < audioContext.currentTime) {\n      when = audioContext.currentTime;\n    }\n\n    for (var i = 0; i < pitches.length; i++) {\n      this.queueWaveTable(audioContext, target, preset, when + i * 0.01, pitches[i], duration, volume - Math.random() * 0.01, slides);\n      volume = 0.9 * volume;\n    }\n  };\n\n  this.queueSnap = function (audioContext, target, preset, when, pitches, duration, volume, slides) {\n    volume = this.limitVolume(volume);\n    volume = 1.5 * (volume || 1.0);\n    duration = 0.05;\n    this.queueChord(audioContext, target, preset, when, pitches, duration, volume, slides);\n  };\n\n  this.queueWaveTable = function (audioContext, target, preset, when, pitch, duration, volume, slides) {\n    if (audioContext.state == 'suspended') {\n      console.log('audioContext.resume');\n      audioContext.resume();\n    }\n\n    volume = this.limitVolume(volume);\n    var zone = this.findZone(audioContext, preset, pitch);\n\n    if (!zone.buffer) {\n      console.log('empty buffer ', zone);\n      return;\n    }\n\n    var baseDetune = zone.originalPitch - 100.0 * zone.coarseTune - zone.fineTune;\n    var playbackRate = 1.0 * Math.pow(2, (100.0 * pitch - baseDetune) / 1200.0);\n    var sampleRatio = zone.sampleRate / audioContext.sampleRate;\n    var startWhen = when;\n\n    if (startWhen < audioContext.currentTime) {\n      startWhen = audioContext.currentTime;\n    }\n\n    var waveDuration = duration + this.afterTime;\n    var loop = true;\n\n    if (zone.loopStart < 1 || zone.loopStart >= zone.loopEnd) {\n      loop = false;\n    }\n\n    if (!loop) {\n      if (waveDuration > zone.buffer.duration / playbackRate) {\n        waveDuration = zone.buffer.duration / playbackRate;\n      }\n    }\n\n    var envelope = this.findEnvelope(audioContext, target, startWhen, waveDuration);\n    this.setupEnvelope(audioContext, envelope, zone, volume, startWhen, waveDuration, duration);\n    envelope.audioBufferSourceNode = audioContext.createBufferSource();\n    envelope.audioBufferSourceNode.playbackRate.setValueAtTime(playbackRate, 0);\n\n    if (slides) {\n      if (slides.length > 0) {\n        envelope.audioBufferSourceNode.playbackRate.setValueAtTime(playbackRate, when);\n\n        for (var i = 0; i < slides.length; i++) {\n          var newPlaybackRate = 1.0 * Math.pow(2, (100.0 * slides[i].pitch - baseDetune) / 1200.0);\n          var newWhen = when + slides[i].when;\n          envelope.audioBufferSourceNode.playbackRate.linearRampToValueAtTime(newPlaybackRate, newWhen);\n        }\n      }\n    }\n\n    envelope.audioBufferSourceNode.buffer = zone.buffer;\n\n    if (loop) {\n      envelope.audioBufferSourceNode.loop = true;\n      envelope.audioBufferSourceNode.loopStart = zone.loopStart / zone.sampleRate + zone.delay;\n      envelope.audioBufferSourceNode.loopEnd = zone.loopEnd / zone.sampleRate + zone.delay;\n    } else {\n      envelope.audioBufferSourceNode.loop = false;\n    }\n\n    envelope.audioBufferSourceNode.connect(envelope);\n    envelope.audioBufferSourceNode.start(startWhen, zone.delay);\n    envelope.audioBufferSourceNode.stop(startWhen + waveDuration);\n    envelope.when = startWhen;\n    envelope.duration = waveDuration;\n    envelope.pitch = pitch;\n    envelope.preset = preset;\n    return envelope;\n  };\n\n  this.noZeroVolume = function (n) {\n    if (n > this.nearZero) {\n      return n;\n    } else {\n      return this.nearZero;\n    }\n  };\n\n  this.setupEnvelope = function (audioContext, envelope, zone, volume, when, sampleDuration, noteDuration) {\n    envelope.gain.setValueAtTime(this.noZeroVolume(0), audioContext.currentTime);\n    var lastTime = 0;\n    var lastVolume = 0;\n    var duration = noteDuration;\n    var ahdsr = zone.ahdsr;\n\n    if (sampleDuration < duration + this.afterTime) {\n      duration = sampleDuration - this.afterTime;\n    }\n\n    if (ahdsr) {\n      if (!(ahdsr.length > 0)) {\n        ahdsr = [{\n          duration: 0,\n          volume: 1\n        }, {\n          duration: 0.5,\n          volume: 1\n        }, {\n          duration: 1.5,\n          volume: 0.5\n        }, {\n          duration: 3,\n          volume: 0\n        }];\n      }\n    } else {\n      ahdsr = [{\n        duration: 0,\n        volume: 1\n      }, {\n        duration: duration,\n        volume: 1\n      }];\n    }\n\n    envelope.gain.cancelScheduledValues(when);\n    envelope.gain.setValueAtTime(this.noZeroVolume(ahdsr[0].volume * volume), when);\n\n    for (var i = 0; i < ahdsr.length; i++) {\n      if (ahdsr[i].duration > 0) {\n        if (ahdsr[i].duration + lastTime > duration) {\n          var r = 1 - (ahdsr[i].duration + lastTime - duration) / ahdsr[i].duration;\n          var n = lastVolume - r * (lastVolume - ahdsr[i].volume);\n          envelope.gain.linearRampToValueAtTime(this.noZeroVolume(volume * n), when + duration);\n          break;\n        }\n\n        lastTime = lastTime + ahdsr[i].duration;\n        lastVolume = ahdsr[i].volume;\n        envelope.gain.linearRampToValueAtTime(this.noZeroVolume(volume * lastVolume), when + lastTime);\n      }\n    }\n\n    envelope.gain.linearRampToValueAtTime(this.noZeroVolume(0), when + duration + this.afterTime);\n  };\n\n  this.numValue = function (aValue, defValue) {\n    if (typeof aValue === \"number\") {\n      return aValue;\n    } else {\n      return defValue;\n    }\n  };\n\n  this.findEnvelope = function (audioContext, target, when, duration) {\n    var envelope = null;\n\n    for (var i = 0; i < this.envelopes.length; i++) {\n      var e = this.envelopes[i];\n\n      if (e.target == target && audioContext.currentTime > e.when + e.duration + 0.001) {\n        try {\n          e.audioBufferSourceNode.disconnect();\n          e.audioBufferSourceNode.stop(0);\n          e.audioBufferSourceNode = null;\n        } catch (x) {//audioBufferSourceNode is dead already\n        }\n\n        envelope = e;\n        break;\n      }\n    }\n\n    if (!envelope) {\n      envelope = audioContext.createGain();\n      envelope.target = target;\n      envelope.connect(target);\n\n      envelope.cancel = function () {\n        if (envelope.when + envelope.duration > audioContext.currentTime) {\n          envelope.gain.cancelScheduledValues(0);\n          envelope.gain.setTargetAtTime(0.00001, audioContext.currentTime, 0.1);\n          envelope.when = audioContext.currentTime + 0.00001;\n          envelope.duration = 0;\n        }\n      };\n\n      this.envelopes.push(envelope);\n    }\n\n    return envelope;\n  };\n\n  this.adjustPreset = function (audioContext, preset) {\n    for (var i = 0; i < preset.zones.length; i++) {\n      this.adjustZone(audioContext, preset.zones[i]);\n    }\n  };\n\n  this.adjustZone = function (audioContext, zone) {\n    if (zone.buffer) {//\n    } else {\n      zone.delay = 0;\n\n      if (zone.sample) {\n        var decoded = atob(zone.sample);\n        zone.buffer = audioContext.createBuffer(1, decoded.length / 2, zone.sampleRate);\n        var float32Array = zone.buffer.getChannelData(0);\n        var b1, b2, n;\n\n        for (var i = 0; i < decoded.length / 2; i++) {\n          b1 = decoded.charCodeAt(i * 2);\n          b2 = decoded.charCodeAt(i * 2 + 1);\n\n          if (b1 < 0) {\n            b1 = 256 + b1;\n          }\n\n          if (b2 < 0) {\n            b2 = 256 + b2;\n          }\n\n          n = b2 * 256 + b1;\n\n          if (n >= 65536 / 2) {\n            n = n - 65536;\n          }\n\n          float32Array[i] = n / 65536.0;\n        }\n      } else {\n        if (zone.file) {\n          var datalen = zone.file.length;\n          var arraybuffer = new ArrayBuffer(datalen);\n          var view = new Uint8Array(arraybuffer);\n          var decoded = atob(zone.file);\n          var b;\n\n          for (var i = 0; i < decoded.length; i++) {\n            b = decoded.charCodeAt(i);\n            view[i] = b;\n          }\n\n          audioContext.decodeAudioData(arraybuffer, function (audioBuffer) {\n            zone.buffer = audioBuffer;\n          });\n        }\n      }\n\n      zone.loopStart = this.numValue(zone.loopStart, 0);\n      zone.loopEnd = this.numValue(zone.loopEnd, 0);\n      zone.coarseTune = this.numValue(zone.coarseTune, 0);\n      zone.fineTune = this.numValue(zone.fineTune, 0);\n      zone.originalPitch = this.numValue(zone.originalPitch, 6000);\n      zone.sampleRate = this.numValue(zone.sampleRate, 44100);\n      zone.sustain = this.numValue(zone.originalPitch, 0);\n    }\n  };\n\n  this.findZone = function (audioContext, preset, pitch) {\n    var zone = null;\n\n    for (var i = preset.zones.length - 1; i >= 0; i--) {\n      zone = preset.zones[i];\n\n      if (zone.keyRangeLow <= pitch && zone.keyRangeHigh + 1 >= pitch) {\n        break;\n      }\n    }\n\n    try {\n      this.adjustZone(audioContext, zone);\n    } catch (ex) {\n      console.log('adjustZone', ex);\n    }\n\n    return zone;\n  };\n\n  this.cancelQueue = function (audioContext) {\n    for (var i = 0; i < this.envelopes.length; i++) {\n      var e = this.envelopes[i];\n      e.gain.cancelScheduledValues(0);\n      e.gain.setValueAtTime(this.nearZero, audioContext.currentTime);\n      e.when = -1;\n\n      try {\n        e.audioBufferSourceNode.disconnect();\n      } catch (ex) {\n        console.log(ex);\n      }\n    }\n  };\n\n  return this;\n}\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = WebAudioFontPlayer;\n}\n\nif (typeof window !== 'undefined') {\n  window.WebAudioFontPlayer = WebAudioFontPlayer;\n}","map":null,"metadata":{},"sourceType":"script"}